
---

### 操作系统开发路线图

#### **第一世代：巩固基础与内存管理 (Epoch 1: Foundation & Memory)**

你现在的内核虽然能工作，但还比较脆弱。这个世代的目标是构建一个健壮的、能够动态管理自己资源的内核，为未来的多任务处理打下坚实的基础。

1.  **实现动态内存分配 (Heap)**
    * **要做什么？** 创建你自己的 `kmalloc()` (kernel malloc) 和 `kfree()` 函数。你不再依赖于预先分配好的静态数组（比如 `fs_nodes`），而是可以在需要时动态地向内核申请一块内存，用完后再归还。
    * **为什么重要？** 这是所有高级功能的基础。没有动态内存，你的文件系统大小、进程数量等都会被写死，无法扩展。
    * **如何入手？** 从最简单的“线性分配器”开始，它只记录一个指针，每次分配内存时就将指针向后移动，但不能释放。然后，你可以挑战更高级的“链表分配器”。

2.  **实现分页机制 (Paging)**
    * **要做什么？** 这是操作系统理论中最核心、也最难的一步。你需要设置 CPU 的页表，将物理内存地址映射到虚拟内存地址。你还需要编写一个“页错误”中断处理函数（对应中断号 14）。
    * **为什么重要？** 分页是现代操作系统的基石。它能提供内存保护（一个程序无法破坏另一个程序的内存）、虚拟内存（让程序以为自己拥有比实际物理内存更大的空间），是实现多任务和用户态/内核态分离的前提。
    * **如何入手？** 这需要大量的理论学习。你需要理解 CR3 寄存器、页目录、页表的结构。从实现一个简单的“恒等映射”（所有虚拟地址都等于物理地址）开始，然后为你的内核创建一个独立的虚拟地址空间。

---

#### **第二世代：多任务处理 (Epoch 2: Multitasking)**

这个世代的目标是让你的内核“活”起来，让它能同时运行多个任务，就像一个真正的操作系统一样。

1.  **创建进程管理**
    * **要做什么？** 定义一个 `task` 或 `process` 结构体，用来保存一个任务的所有状态（寄存器值、栈指针、页目录等）。内核需要一个列表来管理所有的任务。
    * **为什么重要？** 这是实现多任务的基础。内核需要知道每个任务“正在做什么”以及“上次做到哪了”。

2.  **实现任务调度器 (Scheduler)**
    * **要做什么？** 编写一个调度函数。最简单的调度器是“轮询调度 (Round-Robin)”，它会在每次**定时器中断**发生时，保存当前任务的状态，然后从任务列表中选择下一个任务，恢复它的状态，然后继续运行。
    * **为什么重要？** 这是多任务的核心。调度器决定了在任何一个时刻，CPU 应该执行哪个任务的代码。

3.  **实现 `fork()` 系统调用**
    * **要做什么？** 创建第一个真正意义上的“系统调用”。`fork()` 的功能是创建一个与当前任务一模一样的新任务（子进程）。
    * **为什么重要？** 系统调用是用户程序请求内核服务的唯一途径。`fork` 是所有类 Unix 系统中创建新进程的基础。

---

#### **第三世代：用户空间 (Epoch 3: User Space)**

这个世代的目标是在你的内核之上，构建一个可以运行独立应用程序的环境，实现内核与应用的彻底分离。

1.  **加载并运行简单的用户程序**
    * **要做什么？** 单独编写一个最简单的 C 程序（比如打印 "Hello from user space!"），将它编译成一个独立的二进制文件。然后，你的内核需要能够读取这个文件（可以先硬编码到内核里，或者从 Ramdisk 读取），将它加载到内存，并跳转到它的入口点开始执行。
    * **为什么重要？** 这标志着你的项目从一个“内核”正式进化成了一个“操作系统”。

2.  **实现特权级分离 (Ring 0 / Ring 3)**
    * **要做什么？** 在加载用户程序时，你需要将 CPU 的特权级从 Ring 0（内核态）切换到 Ring 3（用户态）。在用户态下，程序不能执行像 `cli`, `hlt` 这样的特权指令，也不能直接访问硬件端口。
    * **为什么重要？** 这是操作系统的安全核心。它保护内核不被用户程序恶意或无意地破坏。

3.  **扩展系统调用**
    * **要做什么？** 为用户程序提供更多的服务，比如 `write_console()`（在屏幕上打印字符）、`read_file()` 等。用户程序通过 `int 0x80` 这样的软中断来触发系统调用，进入内核态。

---

#### **第四世代：持久化与驱动 (Epoch 4: Persistence & Drivers)**

这个世代的目标是让你的操作系统能够与真实的硬件世界交互，并将数据永久地保存下来。

1.  **实现 ATA/IDE 硬盘驱动**
    * **要做什么？** 编写代码，通过 I/O 端口向硬盘控制器发送指令，从而能够读取和写入磁盘上的扇区。
    * **为什么重要？** 它是实现持久化存储的前提。

2.  **实现磁盘文件系统 (如 FAT16/FAT32)**
    * **要做什么？** 在硬盘驱动之上，实现一个真正的文件系统。你需要编写代码来解析文件分配表（FAT），管理目录和文件的存储位置。
    * **为什么重要？** 这能让你的操作系统在关机后依然能保存用户的数据，让它变得真正“有用”。

3.  **编写更多驱动**
    * **可以做什么？** 尝试编写一个串口（Serial Port）驱动，它比屏幕输出更简单，是内核调试的利器。或者，挑战一个符合 VESA (VBE) 标准的简单图形驱动，让你的内核能进入图形模式并画点、画线。

---
